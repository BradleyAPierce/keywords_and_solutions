<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Keywords and Solutions Finder</title>

    <!-- Tailwind CSS -->
    <link
      href="https://cdnjs.cloudflare.com/ajax/libs/tailwindcss/2.2.19/tailwind.min.css"
      rel="stylesheet"
    />

    <!-- React and ReactDOM -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>

    <!-- Babel -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.22.10/babel.min.js"></script>

    <!-- PapaParse for CSV parsing -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>

    <style>
      /* Additional custom styles */
      .line-clamp-2 {
        display: -webkit-box;
        -webkit-line-clamp: 2;
        line-clamp: 2;
        -webkit-box-orient: vertical;
        overflow: hidden;
      }

      /* For the scrollbar */
      ::-webkit-scrollbar {
        width: 8px;
        height: 8px;
      }

      ::-webkit-scrollbar-track {
        background: #f1f1f1;
        border-radius: 10px;
      }

      ::-webkit-scrollbar-thumb {
        background: #c0c0c0;
        border-radius: 10px;
      }

      ::-webkit-scrollbar-thumb:hover {
        background: #a0a0a0;
      }

      /* Loading animation */
      .spinner {
        border: 4px solid rgba(0, 0, 0, 0.1);
        border-radius: 50%;
        border-top: 4px solid #3498db;
        width: 40px;
        height: 40px;
        animation: spin 1s linear infinite;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      /* Tags styling */
      .tag {
        display: inline-block;
        padding: 0.25rem 0.5rem;
        margin: 0.25rem;
        border-radius: 9999px;
        font-size: 0.75rem;
        font-weight: 500;
        background-color: #e5f2ff;
        color: #1e40af;
      }

      /* Transitions */
      .transition-all {
        transition-property: all;
        transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
        transition-duration: 150ms;
      }

      /* Mobile responsiveness */
      @media (max-width: 768px) {
        .sidebar-toggle {
          display: block !important;
        }

        .sidebar {
          position: fixed;
          left: -256px;
          z-index: 50;
          transition: left 0.3s ease;
        }

        .sidebar.open {
          left: 0;
        }

        .overlay {
          display: none;
          position: fixed;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          background-color: rgba(0, 0, 0, 0.5);
          z-index: 40;
        }

        .overlay.open {
          display: block;
        }
      }
    </style>
  </head>
  <body class="bg-gray-50 min-h-screen">
    <!-- Root element for React application -->
    <div id="root" class="min-h-screen"></div>

    <!-- Data Processing Module -->
    <script type="text/babel">
      // Data processing functions
      const DataProcessing = {
        parseCSV(file) {
          try {
            const result = Papa.parse(file, {
              header: true,
              skipEmptyLines: true,
              dynamicTyping: true,
              delimitersToGuess: [",", "\t", "|", ";"], // Try different delimiters
            });

            if (result.errors && result.errors.length > 0) {
              console.warn("CSV parsing warnings:", result.errors);
            }

            return result.data;
          } catch (error) {
            console.error("Error parsing CSV:", error);
            return [];
          }
        },

        processKeywords(rawData) {
          console.log("Processing keywords data:", rawData.length, "rows");
          return rawData.map((row, index) => {
            // Log a sample of the data to help debug
            if (index === 0) {
              console.log("Sample keyword row:", row);
            }

            return {
              id: index,
              keyWord: row["Key Word"] || "",
              solution: row["Solution"] || "",
              industryTrends: row["Industry Trends"] || "",
              keyPhrases: row["Key Words / Key Phrases"] || "",
              qualifyingQuestions: row["Qualifying/Discovery Questions"] || "",
            };
          });
        },

        processSolutions(rawData) {
          console.log("Processing solutions data:", rawData.length, "rows");
          return rawData.map((row, index) => {
            // Log a sample of the data to help debug
            if (index === 0) {
              console.log("Sample solution row:", row);
            }

            return {
              id: index,
              title: row["Solution Title"] || "",
              longDescription: row["Long-Description"] || "",
              shortDescription: row["Short-Description"] || "",
              trends: row["Trends"] || "",
              painPoints: row["Business Pain Points Addressed"] || "",
              verticalRelevance: row["Vertical-Specific Relevance"] || "",
              keyWords: row["Key Words"] || "",
              qualifyingQuestions: row["Qualifying Questions"] || "",
              handlingObjections: row["Handling Objections"] || "",
            };
          });
        },

        mapSolutionsToCategories(keywords, solutions) {
          if (
            !keywords ||
            keywords.length === 0 ||
            !solutions ||
            solutions.length === 0
          ) {
            console.log("Cannot create mapping - missing data", {
              keywordsLength: keywords?.length || 0,
              solutionsLength: solutions?.length || 0,
            });
            return {};
          }

          // Extract unique solutions from keywords
          const keywordSolutions = [
            ...new Set(keywords.map((k) => k.solution).filter(Boolean)),
          ];
          console.log("Unique keyword solutions:", keywordSolutions);

          // Create mapping object
          const mapping = {};

          // For each keyword solution, try to find matching main solution
          keywordSolutions.forEach((kSolution) => {
            // Check for IIM prefix and map to Intelligent Information Management
            if (kSolution && kSolution.startsWith("IIM")) {
              mapping[kSolution] = "Intelligent Information Management";
              return;
            }

            // Check for print-related solutions
            if (
              kSolution &&
              (kSolution.includes("Print") || kSolution === "MICR")
            ) {
              mapping[kSolution] = "Managed  Services"; // Note: double space in original data
              return;
            }

            // Check for security-related solutions
            if (kSolution && kSolution.includes("Security")) {
              mapping[kSolution] = "Security Services";
              return;
            }

            // Check for cloud-related solutions
            if (kSolution && kSolution.includes("Cloud")) {
              mapping[kSolution] = "Cloud Services";
              return;
            }

            // Check for lifecycle/device management
            if (
              kSolution &&
              (kSolution.includes("Lifecycle") || kSolution.includes("Device"))
            ) {
              mapping[kSolution] = "Managed IT Services";
              return;
            }

            // For any other cases, try to find a partial match in solution titles
            const matchingSolution = solutions.find(
              (s) =>
                (kSolution && s.title && kSolution.includes(s.title)) ||
                (kSolution && s.title && s.title.includes(kSolution)) ||
                (kSolution &&
                  s.keyWords &&
                  s.keyWords.toLowerCase().includes(kSolution.toLowerCase()))
            );

            if (matchingSolution) {
              mapping[kSolution] = matchingSolution.title;
            } else {
              // Default to "Other" if no match found
              mapping[kSolution] = "Other";
            }
          });

          console.log("Created solution mapping:", mapping);
          return mapping;
        },

        searchKeywords(keywords, searchTerm) {
          if (!searchTerm) return keywords;

          const term = searchTerm.toLowerCase();
          return keywords.filter((keyword) => {
            // Search in keyword, solution, and key phrases
            return (
              (keyword.keyWord &&
                keyword.keyWord.toLowerCase().includes(term)) ||
              (keyword.solution &&
                keyword.solution.toLowerCase().includes(term)) ||
              (keyword.keyPhrases &&
                keyword.keyPhrases.toLowerCase().includes(term)) ||
              (keyword.industryTrends &&
                keyword.industryTrends.toLowerCase().includes(term)) ||
              (keyword.qualifyingQuestions &&
                keyword.qualifyingQuestions.toLowerCase().includes(term))
            );
          });
        },

        getKeywordsForSolution(keywords, solutionTitle, solutionMapping) {
          if (
            !keywords ||
            keywords.length === 0 ||
            !solutionMapping ||
            Object.keys(solutionMapping).length === 0
          ) {
            return [];
          }

          // Get all keyword solutions that map to this main solution
          const relatedSolutions = Object.entries(solutionMapping)
            .filter(([_, mainSolution]) => mainSolution === solutionTitle)
            .map(([kSolution, _]) => kSolution);

          // Filter keywords by these solutions
          return keywords.filter((keyword) =>
            relatedSolutions.includes(keyword.solution)
          );
        },

        // Helper function to group keywords by solution
        groupKeywordsBySolution(keywords) {
          const groups = {};

          keywords.forEach((keyword) => {
            if (keyword.solution) {
              if (!groups[keyword.solution]) {
                groups[keyword.solution] = [];
              }
              groups[keyword.solution].push(keyword);
            }
          });

          return groups;
        },
      };

      window.DataProcessing = DataProcessing;
    </script>

    <!-- Main Application -->
    <script type="text/babel">
      const { useState, useEffect, useRef } = React;

      // Main application component
      function KeyWordsAndSolutionsApp() {
        // State for data
        const [keywords, setKeywords] = useState([]);
        const [solutions, setSolutions] = useState([]);
        const [solutionMapping, setSolutionMapping] = useState({});
        const [isLoading, setIsLoading] = useState(true);
        const [error, setError] = useState(null);

        // State for UI
        const [searchTerm, setSearchTerm] = useState("");
        const [selectedSolutions, setSelectedSolutions] = useState([]);
        const [activeKeyword, setActiveKeyword] = useState(null);
        const [view, setView] = useState("keywords"); // 'keywords' or 'solutions'
        const [sidebarOpen, setSidebarOpen] = useState(false); // For mobile view

        // Load CSV files
        useEffect(() => {
          const fetchCSVs = async () => {
            setIsLoading(true);
            console.log("Fetching CSV files...");

            // Fetch the keywords CSV file
            try {
              console.log("Fetching keywords CSV...");
              const keywordsResponse = await fetch(
                "./csv-files/key-words-detailscsv.csv"
              );
              if (!keywordsResponse.ok) {
                throw new Error(
                  `Failed to fetch keywords CSV: ${keywordsResponse.status} ${keywordsResponse.statusText}`
                );
              }
              const keywordsText = await keywordsResponse.text();
              console.log(
                "Keywords CSV content received, length:",
                keywordsText.length
              );

              if (keywordsText.length > 0) {
                console.log(
                  "Keywords CSV content (first 100 chars):",
                  keywordsText.substring(0, 100)
                );
                const keywordsRaw = DataProcessing.parseCSV(keywordsText);
                const processedKeywords =
                  DataProcessing.processKeywords(keywordsRaw);
                setKeywords(processedKeywords);
                console.log("Keywords loaded:", processedKeywords.length);
              } else {
                console.error("Keywords CSV content is empty");
                setError(
                  "Keywords CSV file is empty. Please check the file content."
                );
              }
            } catch (err) {
              console.error("Error loading keywords data:", err);
              setError(
                "Failed to load keywords data. Please check that the CSV file is accessible."
              );
            }

            // Fetch the solutions CSV file
            try {
              console.log("Fetching solutions CSV...");
              const solutionsResponse = await fetch(
                "./csv-files/solutions_base_template_csv.csv"
              );
              if (!solutionsResponse.ok) {
                throw new Error(
                  `Failed to fetch solutions CSV: ${solutionsResponse.status} ${solutionsResponse.statusText}`
                );
              }
              const solutionsText = await solutionsResponse.text();
              console.log(
                "Solutions CSV content received, length:",
                solutionsText.length
              );

              if (solutionsText.length > 0) {
                console.log(
                  "Solutions CSV content (first 100 chars):",
                  solutionsText.substring(0, 100)
                );
                const solutionsRaw = DataProcessing.parseCSV(solutionsText);
                const processedSolutions =
                  DataProcessing.processSolutions(solutionsRaw);
                setSolutions(processedSolutions);
                console.log("Solutions loaded:", processedSolutions.length);
              } else {
                console.error("Solutions CSV content is empty");
                setError(
                  "Solutions CSV file is empty. Please check the file content."
                );
              }
            } catch (err) {
              console.error("Error loading solutions data:", err);
              setError(
                "Failed to load solutions data. Please check that the CSV file is accessible."
              );
            }
          };

          fetchCSVs();
        }, []);

        // Create mapping between solutions when both datasets are loaded
        useEffect(() => {
          if (keywords.length > 0 && solutions.length > 0) {
            console.log("Creating solution mapping...");
            const mapping = DataProcessing.mapSolutionsToCategories(
              keywords,
              solutions
            );
            setSolutionMapping(mapping);
            setIsLoading(false);
          } else if (
            !isLoading &&
            keywords.length === 0 &&
            solutions.length === 0
          ) {
            console.log("No data loaded, setting error");
            setError("No data loaded. Please check the CSV files.");
          }
        }, [keywords, solutions]);

        // Filter keywords based on search term and selected solutions
        const filteredKeywords = keywords.filter((keyword) => {
          // Filter by search term
          const matchesSearch =
            searchTerm === "" ||
            (keyword.keyWord &&
              keyword.keyWord
                .toLowerCase()
                .includes(searchTerm.toLowerCase())) ||
            (keyword.keyPhrases &&
              keyword.keyPhrases
                .toLowerCase()
                .includes(searchTerm.toLowerCase())) ||
            (keyword.industryTrends &&
              keyword.industryTrends
                .toLowerCase()
                .includes(searchTerm.toLowerCase())) ||
            (keyword.qualifyingQuestions &&
              keyword.qualifyingQuestions
                .toLowerCase()
                .includes(searchTerm.toLowerCase()));

          // Filter by selected solutions
          const matchesSolution =
            selectedSolutions.length === 0 ||
            selectedSolutions.some((solution) => {
              // Get the main solution for this keyword
              const mainSolution = solutionMapping[keyword.solution];
              return solution === mainSolution || solution === keyword.solution;
            });

          return matchesSearch && matchesSolution;
        });

        // Handle solution selection
        const toggleSolution = (solutionTitle) => {
          setSelectedSolutions((prev) =>
            prev.includes(solutionTitle)
              ? prev.filter((s) => s !== solutionTitle)
              : [...prev, solutionTitle]
          );
        };

        // Switch between keywords and solutions view
        const toggleView = (newView) => {
          setView(newView);
          setActiveKeyword(null); // Reset active keyword when switching views
        };

        // Toggle sidebar for mobile view
        const toggleSidebar = () => {
          setSidebarOpen(!sidebarOpen);
        };

        // Close sidebar when clicking outside
        const closeSidebar = () => {
          setSidebarOpen(false);
        };

        return (
          <div className="flex flex-col h-screen bg-gray-50">
            {/* Header with search */}
            <header className="bg-blue-700 text-white p-4 shadow-md z-10">
              <div className="container mx-auto flex items-center">
                {/* Mobile menu button */}
                <button
                  className="sidebar-toggle mr-4 p-1 rounded-md hover:bg-blue-600 focus:outline-none hidden"
                  onClick={toggleSidebar}
                >
                  <svg
                    className="w-6 h-6"
                    fill="none"
                    stroke="currentColor"
                    viewBox="0 0 24 24"
                    xmlns="http://www.w3.org/2000/svg"
                  >
                    <path
                      strokeLinecap="round"
                      strokeLinejoin="round"
                      strokeWidth="2"
                      d="M4 6h16M4 12h16M4 18h16"
                    ></path>
                  </svg>
                </button>

                <h1 className="text-2xl font-bold mb-4">
                  Keywords and Solutions Finder
                </h1>
              </div>

              <div className="container mx-auto">
                <div className="relative">
                  <input
                    type="text"
                    placeholder="Search for keywords..."
                    className="w-full p-2 pl-10 rounded text-gray-800"
                    value={searchTerm}
                    onChange={(e) => setSearchTerm(e.target.value)}
                  />
                  <svg
                    className="absolute left-3 top-2.5 text-gray-500"
                    width="20"
                    height="20"
                    viewBox="0 0 24 24"
                    fill="none"
                    stroke="currentColor"
                    strokeWidth="2"
                    strokeLinecap="round"
                    strokeLinejoin="round"
                  >
                    <circle cx="11" cy="11" r="8"></circle>
                    <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
                  </svg>
                </div>
              </div>
            </header>

            {/* Mobile overlay */}
            <div
              className={`overlay ${sidebarOpen ? "open" : ""}`}
              onClick={closeSidebar}
            ></div>

            {/* Main content area */}
            <div className="flex flex-1 overflow-hidden">
              {/* Sidebar */}
              <aside
                className={`sidebar w-64 bg-white p-4 border-r border-gray-200 overflow-y-auto ${
                  sidebarOpen ? "open" : ""
                }`}
              >
                <div className="mb-4">
                  <h2 className="text-lg font-semibold mb-2">View</h2>
                  <div className="flex space-x-2 mb-4">
                    <button
                      className={`px-3 py-1 rounded ${
                        view === "keywords"
                          ? "bg-blue-600 text-white"
                          : "bg-gray-200"
                      }`}
                      onClick={() => toggleView("keywords")}
                    >
                      Keywords
                    </button>
                    <button
                      className={`px-3 py-1 rounded ${
                        view === "solutions"
                          ? "bg-blue-600 text-white"
                          : "bg-gray-200"
                      }`}
                      onClick={() => toggleView("solutions")}
                    >
                      Solutions
                    </button>
                  </div>
                </div>

                <h2 className="text-lg font-semibold mb-2">Solutions</h2>
                {isLoading ? (
                  <p>Loading solutions...</p>
                ) : (
                  <div className="space-y-4">
                    {/* Main Solutions */}
                    <div className="space-y-2">
                      <h3 className="text-sm font-medium text-gray-700">
                        Main Solutions
                      </h3>
                      {solutions.map((solution) => (
                        <div key={solution.id} className="flex items-center">
                          <input
                            type="checkbox"
                            id={`solution-${solution.id}`}
                            checked={selectedSolutions.includes(solution.title)}
                            onChange={() => toggleSolution(solution.title)}
                            className="mr-2"
                          />
                          <label
                            htmlFor={`solution-${solution.id}`}
                            className="text-sm"
                          >
                            {solution.title}
                          </label>
                        </div>
                      ))}
                    </div>

                    {/* Keyword Solutions */}
                    <div className="space-y-2">
                      <h3 className="text-sm font-medium text-gray-700">
                        Keyword Solutions
                      </h3>
                      {Object.keys(solutionMapping).map(
                        (keywordSolution, idx) => (
                          <div
                            key={`ksolution-${idx}`}
                            className="flex items-center"
                          >
                            <input
                              type="checkbox"
                              id={`ksolution-${idx}`}
                              checked={selectedSolutions.includes(
                                keywordSolution
                              )}
                              onChange={() => toggleSolution(keywordSolution)}
                              className="mr-2"
                            />
                            <label
                              htmlFor={`ksolution-${idx}`}
                              className="text-sm"
                            >
                              {keywordSolution}
                            </label>
                          </div>
                        )
                      )}
                    </div>
                  </div>
                )}
              </aside>

              {/* Main content */}
              <main className="flex-1 p-6 overflow-y-auto">
                {isLoading ? (
                  <div className="flex justify-center items-center h-full">
                    <div className="spinner"></div>
                    <p className="ml-4 text-lg">Loading content...</p>
                  </div>
                ) : error ? (
                  <div className="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded">
                    <p className="font-bold">Error</p>
                    <p>{error}</p>
                    <div className="mt-4">
                      <p className="text-sm">Troubleshooting tips:</p>
                      <ul className="list-disc pl-5 text-sm mt-2">
                        <li>
                          Make sure the CSV files exist in the{" "}
                          <code>csv-files</code> directory
                        </li>
                        <li>
                          Check that the file names are correct:{" "}
                          <code>key-words-detailscsv.csv</code> and{" "}
                          <code>solutions_base_template_csv.csv</code>
                        </li>
                        <li>
                          Verify that the CSV files have the expected columns
                        </li>
                        <li>Try refreshing the page</li>
                      </ul>
                    </div>
                  </div>
                ) : view === "keywords" ? (
                  <div>
                    {activeKeyword ? (
                      <KeywordDetail
                        keyword={activeKeyword}
                        onBack={() => setActiveKeyword(null)}
                      />
                    ) : (
                      <KeywordsList
                        keywords={filteredKeywords}
                        onSelectKeyword={setActiveKeyword}
                      />
                    )}
                  </div>
                ) : (
                  <SolutionsList
                    solutions={solutions.filter(
                      (s) =>
                        selectedSolutions.length === 0 ||
                        selectedSolutions.includes(s.title)
                    )}
                  />
                )}
              </main>
            </div>
          </div>
        );
      }

      // Component for the keywords list
      function KeywordsList({ keywords, onSelectKeyword }) {
        if (keywords.length === 0) {
          return (
            <div className="text-center py-10">
              <p className="text-gray-500">
                No keywords match your search criteria.
              </p>
              <p className="text-sm text-gray-400 mt-2">
                Try adjusting your search or solution filters.
              </p>
            </div>
          );
        }

        // Group keywords by solution for better organization
        const keywordsBySolution = {};
        keywords.forEach((keyword) => {
          if (!keywordsBySolution[keyword.solution]) {
            keywordsBySolution[keyword.solution] = [];
          }
          keywordsBySolution[keyword.solution].push(keyword);
        });

        return (
          <div>
            <h2 className="text-xl font-semibold mb-4">
              Keywords ({keywords.length})
            </h2>

            {/* Display grouped by solution */}
            {Object.entries(keywordsBySolution).map(
              ([solution, solutionKeywords]) => (
                <div key={solution} className="mb-8">
                  <h3 className="text-lg font-medium text-blue-700 mb-3 border-b border-blue-200 pb-2">
                    {solution}
                  </h3>
                  <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                    {solutionKeywords.map((keyword) => (
                      <div
                        key={keyword.id}
                        className="bg-white rounded-lg shadow p-4 cursor-pointer hover:shadow-md transition-shadow border-l-4 border-blue-500"
                        onClick={() => onSelectKeyword(keyword)}
                      >
                        <h3 className="font-semibold text-lg mb-2">
                          {keyword.keyWord}
                        </h3>
                        <p className="text-xs text-gray-500 mb-2">
                          {keyword.keyPhrases && (
                            <>
                              Related to:{" "}
                              {keyword.keyPhrases
                                .split(",")
                                .slice(0, 3)
                                .map((phrase) => (
                                  <span key={phrase} className="tag">
                                    {phrase.trim()}
                                  </span>
                                ))}
                              {keyword.keyPhrases.split(",").length > 3 && (
                                <span className="text-xs">...</span>
                              )}
                            </>
                          )}
                        </p>
                        <div className="flex justify-end">
                          <span className="text-xs text-blue-500 hover:underline">
                            View details â†’
                          </span>
                        </div>
                      </div>
                    ))}
                  </div>
                </div>
              )
            )}
          </div>
        );
      }

      // Component for keyword details
      function KeywordDetail({ keyword, onBack }) {
        // Refs for sections to enable smooth scrolling
        const trendsRef = useRef(null);
        const phrasesRef = useRef(null);
        const questionsRef = useRef(null);

        // Scroll to section function
        const scrollToSection = (ref) => {
          ref.current.scrollIntoView({ behavior: "smooth" });
        };

        return (
          <div className="bg-white rounded-lg shadow-md p-6">
            <button
              onClick={onBack}
              className="mb-4 px-3 py-1 bg-gray-200 rounded hover:bg-gray-300 transition-colors flex items-center"
            >
              <svg
                xmlns="http://www.w3.org/2000/svg"
                className="h-4 w-4 mr-1"
                viewBox="0 0 20 20"
                fill="currentColor"
              >
                <path
                  fillRule="evenodd"
                  d="M9.707 14.707a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414l4-4a1 1 0 011.414 1.414L7.414 9H15a1 1 0 110 2H7.414l2.293 2.293a1 1 0 010 1.414z"
                  clipRule="evenodd"
                />
              </svg>
              Back to Keywords
            </button>

            <div className="border-l-4 border-blue-500 pl-4 mb-6">
              <h2 className="text-2xl font-bold mb-2">{keyword.keyWord}</h2>
              <p className="text-blue-600 mb-1">Solution: {keyword.solution}</p>
            </div>

            {/* Quick navigation */}
            <div className="flex flex-wrap gap-2 mb-6">
              <button
                onClick={() => scrollToSection(trendsRef)}
                className="px-3 py-1 bg-blue-100 text-blue-700 rounded-full text-sm hover:bg-blue-200 transition-colors"
              >
                Industry Trends
              </button>
              <button
                onClick={() => scrollToSection(phrasesRef)}
                className="px-3 py-1 bg-blue-100 text-blue-700 rounded-full text-sm hover:bg-blue-200 transition-colors"
              >
                Key Phrases
              </button>
              <button
                onClick={() => scrollToSection(questionsRef)}
                className="px-3 py-1 bg-blue-100 text-blue-700 rounded-full text-sm hover:bg-blue-200 transition-colors"
              >
                Qualifying Questions
              </button>
            </div>

            <div className="space-y-6">
              <section ref={trendsRef} className="bg-gray-50 p-4 rounded-lg">
                <h3 className="text-lg font-semibold mb-2 text-blue-700">
                  Industry Trends
                </h3>
                <div className="text-gray-700 whitespace-pre-line">
                  {keyword.industryTrends || "No industry trends available"}
                </div>
              </section>

              <section ref={phrasesRef} className="bg-gray-50 p-4 rounded-lg">
                <h3 className="text-lg font-semibold mb-2 text-blue-700">
                  Key Words / Key Phrases
                </h3>
                <div className="flex flex-wrap gap-2">
                  {keyword.keyPhrases ? (
                    keyword.keyPhrases.split(",").map((phrase, i) => (
                      <span
                        key={i}
                        className="bg-blue-100 text-blue-800 px-2 py-1 rounded-full text-sm"
                      >
                        {phrase.trim()}
                      </span>
                    ))
                  ) : (
                    <p className="text-gray-500">No key phrases available</p>
                  )}
                </div>
              </section>

              <section ref={questionsRef} className="bg-gray-50 p-4 rounded-lg">
                <h3 className="text-lg font-semibold mb-2 text-blue-700">
                  Qualifying/Discovery Questions
                </h3>
                <div className="text-gray-700">
                  {keyword.qualifyingQuestions ? (
                    <ul className="space-y-2">
                      {keyword.qualifyingQuestions
                        .split("\n\n")
                        .filter(Boolean)
                        .map((question, i) => (
                          <li
                            key={i}
                            className="bg-white p-3 rounded border-l-2 border-blue-300"
                          >
                            {question}
                          </li>
                        ))}
                    </ul>
                  ) : (
                    <p className="text-gray-500">
                      No qualifying questions available
                    </p>
                  )}
                </div>
              </section>
            </div>
          </div>
        );
      }

      // Component for solutions list
      function SolutionsList({ solutions }) {
        if (solutions.length === 0) {
          return (
            <div className="text-center py-10">
              <p className="text-gray-500">
                No solutions selected. Please select at least one solution from
                the sidebar.
              </p>
            </div>
          );
        }

        return (
          <div className="space-y-8">
            <h2 className="text-xl font-semibold mb-4">
              Solutions ({solutions.length})
            </h2>

            {solutions.map((solution) => (
              <div
                key={solution.id}
                className="bg-white rounded-lg shadow-md overflow-hidden"
              >
                {/* Solution header */}
                <div className="bg-blue-600 text-white p-4">
                  <h3 className="text-xl font-bold">{solution.title}</h3>
                  <p className="mt-1 text-blue-100">
                    {solution.shortDescription}
                  </p>
                </div>

                {/* Solution details */}
                <div className="p-6 space-y-6">
                  <section>
                    <h4 className="text-lg font-semibold mb-2 text-blue-700">
                      Description
                    </h4>
                    <p className="text-gray-700 whitespace-pre-line">
                      {solution.longDescription}
                    </p>
                  </section>

                  <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                    <section className="bg-gray-50 p-4 rounded-lg">
                      <h4 className="text-lg font-semibold mb-3 text-blue-700">
                        Trends
                      </h4>
                      <div className="text-gray-700">
                        {solution.trends ? (
                          <ul className="space-y-2">
                            {solution.trends
                              .split("\n")
                              .filter(Boolean)
                              .map((trend, i) => (
                                <li key={i} className="flex items-start">
                                  <svg
                                    className="h-5 w-5 text-blue-500 mr-2 mt-0.5 flex-shrink-0"
                                    fill="none"
                                    viewBox="0 0 24 24"
                                    stroke="currentColor"
                                  >
                                    <path
                                      strokeLinecap="round"
                                      strokeLinejoin="round"
                                      strokeWidth="2"
                                      d="M9 5l7 7-7 7"
                                    />
                                  </svg>
                                  <span>{trend}</span>
                                </li>
                              ))}
                          </ul>
                        ) : (
                          <p className="text-gray-500">No trends available</p>
                        )}
                      </div>
                    </section>

                    <section className="bg-gray-50 p-4 rounded-lg">
                      <h4 className="text-lg font-semibold mb-3 text-blue-700">
                        Business Pain Points Addressed
                      </h4>
                      <div className="text-gray-700">
                        {solution.painPoints ? (
                          <ul className="space-y-2">
                            {solution.painPoints
                              .split("\n")
                              .filter(Boolean)
                              .map((point, i) => (
                                <li key={i} className="flex items-start">
                                  <svg
                                    className="h-5 w-5 text-red-500 mr-2 mt-0.5 flex-shrink-0"
                                    fill="none"
                                    viewBox="0 0 24 24"
                                    stroke="currentColor"
                                  >
                                    <path
                                      strokeLinecap="round"
                                      strokeLinejoin="round"
                                      strokeWidth="2"
                                      d="M18 9v3m0 0v3m0-3h3m-3 0h-3m-2-5a4 4 0 11-8 0 4 4 0 018 0zM3 20a6 6 0 0112 0v1H3v-1z"
                                    />
                                  </svg>
                                  <span>{point}</span>
                                </li>
                              ))}
                          </ul>
                        ) : (
                          <p className="text-gray-500">
                            No pain points available
                          </p>
                        )}
                      </div>
                    </section>
                  </div>

                  <section className="bg-gray-50 p-4 rounded-lg">
                    <h4 className="text-lg font-semibold mb-2 text-blue-700">
                      Vertical-Specific Relevance
                    </h4>
                    <div className="text-gray-700 whitespace-pre-line">
                      {solution.verticalRelevance ? (
                        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                          {solution.verticalRelevance
                            .split("\n")
                            .filter(Boolean)
                            .map((vertical, i) => {
                              const parts = vertical.split(":");
                              const industry = parts.shift(); // Get the first part
                              const description = parts.join(":"); // Rejoin the rest in case there are multiple colons

                              return (
                                <div
                                  key={i}
                                  className="bg-white p-3 rounded border-l-2 border-blue-400"
                                >
                                  {industry && description ? (
                                    <>
                                      <strong className="text-blue-800">
                                        {industry.trim()}:
                                      </strong>
                                      <span>{description.trim()}</span>
                                    </>
                                  ) : (
                                    <span>{vertical}</span>
                                  )}
                                </div>
                              );
                            })}
                        </div>
                      ) : (
                        <p className="text-gray-500">
                          No vertical-specific relevance available
                        </p>
                      )}
                    </div>
                  </section>

                  {solution.qualifyingQuestions && (
                    <section className="bg-gray-50 p-4 rounded-lg">
                      <h4 className="text-lg font-semibold mb-2 text-blue-700">
                        Qualifying Questions
                      </h4>
                      <div className="text-gray-700">
                        <ul className="space-y-2">
                          {solution.qualifyingQuestions
                            .split(";")
                            .filter(Boolean)
                            .map((question, i) => (
                              <li
                                key={i}
                                className="bg-white p-3 rounded border-l-2 border-green-400"
                              >
                                {question.trim()}
                              </li>
                            ))}
                        </ul>
                      </div>
                    </section>
                  )}

                  {solution.handlingObjections && (
                    <section className="bg-gray-50 p-4 rounded-lg">
                      <h4 className="text-lg font-semibold mb-2 text-blue-700">
                        Handling Objections
                      </h4>
                      <div className="text-gray-700">
                        <ul className="space-y-2">
                          {solution.handlingObjections
                            .split(";")
                            .filter(Boolean)
                            .map((objection, i) => (
                              <li
                                key={i}
                                className="bg-white p-3 rounded border-l-2 border-yellow-400"
                              >
                                {objection.trim()}
                              </li>
                            ))}
                        </ul>
                      </div>
                    </section>
                  )}
                </div>
              </div>
            ))}
          </div>
        );
      }

      // Enhanced error boundary component
      class ErrorBoundary extends React.Component {
        constructor(props) {
          super(props);
          this.state = { hasError: false, error: null, errorInfo: null };
        }

        static getDerivedStateFromError(error) {
          return { hasError: true };
        }

        componentDidCatch(error, errorInfo) {
          this.setState({
            error: error,
            errorInfo: errorInfo,
          });
          console.error("Error caught by boundary:", error, errorInfo);
        }

        render() {
          if (this.state.hasError) {
            return (
              <div className="p-4 bg-red-100 border border-red-400 text-red-700 rounded">
                <h2 className="text-xl font-bold mb-2">Something went wrong</h2>
                <p className="mb-2">
                  The application encountered an error. Please try refreshing
                  the page.
                </p>
                <details className="bg-white p-2 rounded text-sm">
                  <summary className="cursor-pointer">
                    Technical Details
                  </summary>
                  <p className="mt-2">
                    {this.state.error && this.state.error.toString()}
                  </p>
                  <pre className="mt-2 overflow-auto p-2 bg-gray-100 rounded">
                    {this.state.errorInfo &&
                      this.state.errorInfo.componentStack}
                  </pre>
                </details>
                <button
                  onClick={() => window.location.reload()}
                  className="mt-4 bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded"
                >
                  Refresh Page
                </button>
              </div>
            );
          }

          return this.props.children;
        }
      }

      // Render the application with error boundary
      ReactDOM.render(
        <ErrorBoundary>
          <KeyWordsAndSolutionsApp />
        </ErrorBoundary>,
        document.getElementById("root")
      );
    </script>
  </body>
</html>
